package main

import (
	"regexp"
	"strings"
	"unicode"
)

// This file contains func check_for_match_in_other_fields and all of its supporting functions

func isSingleDigit(usersGuess string) bool { // - -
	// fmt.Println("In isSingleDigit")
	// Define a regular expression pattern to match a single alpha string digit char from 1 to 9

	pattern := `^[1-9]$`

	// Compile the regular expression
	reg := regexp.MustCompile(pattern)

	// Use the regular expression reg to match against usersGuess
	return reg.MatchString(usersGuess)
}
func isDoubleDigit(usersGuess string) bool { // - -
	// fmt.Println("In isDoubleDigit")
	// Define a regular expression pattern to match a double-digit alpha string from 10 to 99
	pattern := `^[1-9][0-9]$`

	// Compile the regular expression
	reg := regexp.MustCompile(pattern)

	// Use the regular expression reg to match against usersGuess
	return reg.MatchString(usersGuess)
}

/* I was trying the following two functions, but I failed
func checkDelimiters(r rune, delimiters string) bool {
	for _, d := range delimiters { // delimiters is a passed string, as discussed above
		if r == d { //
			return true
		}
	}
	// return false
	return false
}
func customSplit(str, delimiters string) []string {
	return strings.FieldsFunc(str, checkDelimiters)
}

*/

// The two (commented) above functions were to be equivalent to the following, but I failed
// Caller passes two strings, one to split, and a string of delimiters; as of last writing: delimiters := ";, -().:"
func customSplit(str, delimiters string) []string {
	// fmt.Println("In customSplit")

	// isDelimiter is a custom lambda function which checks if a rune is one of the specified delimiters ...
	// and, it checks to see if delimiter is found as a char in str, see the discussion below
	isDelimiter := func(r rune) bool { // See the discussion below // Attempted to make checkDelimiters equivalent to isDelimiter: failed
		for _, d := range delimiters { // delimiters is a passed string, as of last writing: delimiters := ";, -().:"
			if r == d { //
				return true
			}
		}
		/*
				isDelimiter is a function literal (also known as a lambda function or anonymous function) that takes a rune
				as its input parameter and returns a boolean value.

			Here's a breakdown of what the isDelimiter function literal does:

				isDelimiter := func(r rune) bool {: This line defines an anonymous function and assigns it to the variable isDelimiter.
				The function takes a single parameter, r, which is a rune (a Unicode character). It returns a boolean value (true or false).

				for _, d := range delimiters {: This is a for loop that iterates over each character (d) in the delimiters string.
				The range loop iterates over the string, character by character.

				if r == d {: Within the loop, there is an if statement that checks if the rune r is equal to the current character d from
				the delimiters string.

				return true: If a match is found (i.e., if r is equal to d), the function immediately returns true. This means that the
				input r is considered to have been a delimiter character.

				If the loop completes without finding a match, the function implicitly returns false by not hitting the return true statement.

				So, the purpose of this function is to check if a given rune (Unicode character) is one of the specified delimiters contained
				in the delimiters string. It returns true if it's a delimiter and false otherwise. This function is used as the custom delimiter
				function in the strings.FieldsFunc call (below) to split a string based on these delimiters.
		*/
		return false
	}

	//
	// In the last line of code (the return) we use FieldsFunc to split the string based on the custom delimiter function isDelimiter
	/*
		strings.FieldsFunc(str, isDelimiter): This function call invokes the strings.FieldsFunc function, passing two arguments:
		the input string str and the custom delimiter function isDelimiter. The purpose of strings.FieldsFunc is to split the input string into
		fields based on the criteria defined by the delimiter function.

		return ...: The return statement is used to return the result of the function call as the result of the current function. In this case,
		it's returning the fields that were generated by splitting the str string based on the delimiter function.

		So, when we call return strings.FieldsFunc(str, isDelimiter), it effectively returns the split fields as a result. The result of this
		expression is a slice of strings representing the split fields, and this result becomes the return value of the function where this
		return statement is used.
	*/
	return strings.FieldsFunc(str, isDelimiter)
	// end of func : customSplit(str, delimiters string) []string { // Called only once, below - - THERE *****
}

func customMatch2digits(our_guess, str string) bool {
	// Let's work only with lower-case versions of our data
	ourGuessLower := strings.ToLower(our_guess)
	strLower := strings.ToLower(str)

	delimiters := ";, -().:"                      // - - - - - - - - - - - - - - - - - - - - - -   HERE *****
	strParts := customSplit(strLower, delimiters) // This is the only time that "customSplit(str, delimiters string) []string" is called
	for _, part := range strParts {               // Read through the slice: strParts to obtain each part
		// fmt.Printf("Here is a part from customMatch2digits: %s \n", part)
		if ourGuessLower == part {
			// fmt.Println("the condition is met")
			return true
		}
	}
	return false
}
func check_for_match_within_primary_field(users_guess string) bool {
	// Look everywhere (in every field of the card) v v v v v v
	fields_from_aCard := []string{aCard.Meaning}

	// In the case of a one or two-char users_guess, we want now to check if we are dealing with a guess of a digit char, like "3"
	if len(users_guess) < 3 { // if the guess is only one or two chars long then we call it a miss, unless possibly it is a digit char or two

		if isSingleDigit(users_guess) {
			// println("It is a isSingleDigit")
			for _, one_field_from_aCard := range fields_from_aCard { // Read through the slice of fields from aCard (see above)
				// If we want to know what the position was, could use n instead of _ to print it
				if customMatch(users_guess, one_field_from_aCard) {
					// fmt.Printf("Tossed value is position number:%v\n", n)
					/*
						if n != 99999 { // Just a silly kluge ...
							n = 0 // We had to use n for something, since we chose not to toss the returned parameter via a _,
						}
					*/
					return true // else ...
				}
			}
		}
		// Next, we will check if it is a double-digit like "34"
		if isDoubleDigit(users_guess) {
			// println("It is a isDoubleDigit")
			for _, one_field_from_aCard := range fields_from_aCard { // Read through the slice of fields from aCard (see above ^ ^ )
				// If we want to know what the position was, could use n instead of _ to print it
				// customMatch2digits is required because we don't want to match on a single digit, and customMatch does that!
				if customMatch2digits(users_guess, one_field_from_aCard) { // Go check the sub parts of one_field_from_aCard
					/*
						if n != 99999 { // Just a silly kluge ...
							n = 0 // We had to use n for something, since we chose not to toss the returned parameter via a _,
						}
					*/
					// fmt.Println("Why is customMatch2digits returning true?")
					// Only v v v return true if customMatch2digits returns true (thereby putting us here)
					return true // else ... continue, and if we never exit via this return, we eventually return false, below
				}
			}
			// else ...
			return false
		}
		// else return false
		// return false // For now we just return false in the case of a very short guess, but this line will go away once we implement the above code
	} else {
		for _, one_field_from_aCard := range fields_from_aCard { // Read through the slice of fields from aCard (see above)
			// If we want to know what the position was, could use n instead of _ to print it
			if customMatch(users_guess, one_field_from_aCard) {
				// fmt.Printf("Tossed value is position number:%v\n", n) // If we want to know what the position was, we could use n instead of _ to print it
				/*
					if n != 99999 { // Just a silly kluge ...
						n = 0 // We had to use n for something, since we chose not to toss the returned parameter via a _,
					}
				*/
				// fmt.Printf("Why is customMatch returning true? one_field_from_aCard:%s\n", one_field_from_aCard)
				// one_field_from_aCard is nil ??? ^ ^ ^
				// we are only here if customMatch returned true
				return true
			}
		}
	}
	// else
	return false
}
func check_for_match_in_other_fields(users_guess string) bool {
	// Look everywhere (in every field of the card) v v v v v v
	// fields_from_aCard := []string{aCard.Meaning, aCard.Second_Meaning, aCard.Kunyomi, aCard.Onyomi, aCard.Vocab, aCard.Vocab2}
	fields_from_aCard := []string{aCard.Second_Meaning, aCard.Kunyomi, aCard.Onyomi, aCard.Vocab, aCard.Vocab2}

	// In the case of a one or two-char users_guess, we want now to check if we are dealing with a guess of a digit char, like "3"
	if len(users_guess) < 3 { // if the guess is only one or two chars long then we call it a miss, unless possibly it is a digit char or two

		if isSingleDigit(users_guess) {
			// println("It is a isSingleDigit")
			for _, one_field_from_aCard := range fields_from_aCard { // Read through the slice of fields from aCard (see above)
				// If we want to know what the position was, could use n instead of _ to print it
				if customMatch(users_guess, one_field_from_aCard) {
					// fmt.Printf("Tossed value is position number:%v\n", n)
					/*
						if n != 99999 { // Just a silly kluge ...
							n = 0 // We had to use n for something, since we chose not to toss the returned parameter via a _,
						}
					*/
					return true // else ...
				}
			}
		}
		// Next, we will check if it is a double-digit like "34"
		if isDoubleDigit(users_guess) {
			// println("It is a isDoubleDigit")
			for _, one_field_from_aCard := range fields_from_aCard { // Read through the slice of fields from aCard (see above ^ ^ )
				// If we want to know what the position was, could use n instead of _ to print it
				// customMatch2digits is required because we don't want to match on a single digit, and customMatch does that!
				if customMatch2digits(users_guess, one_field_from_aCard) { // Go check the sub parts of one_field_from_aCard
					/*
						if n != 99999 { // Just a silly kluge ...
							n = 0 // We had to use n for something, since we chose not to toss the returned parameter via a _,
						}
					*/
					// fmt.Println("Why is customMatch2digits returning true?")
					// Only v v v return true if customMatch2digits returns true (thereby putting us here)
					return true // else ... continue, and if we never exit via this return, we eventually return false, below
				}
			}
			// else ...
			return false
		}
		// else return false
		// return false // For now we just return false in the case of a very short guess, but this line will go away once we implement the above code
	} else {
		for _, one_field_from_aCard := range fields_from_aCard { // Read through the slice of fields from aCard (see above)
			// If we want to know what the position was, could use n instead of _ to print it
			if customMatch(users_guess, one_field_from_aCard) {
				// fmt.Printf("Tossed value is position number:%v\n", n) // If we want to know what the position was, we could use n instead of _ to print it
				/*
					if n != 99999 { // Just a silly kluge ...
						n = 0 // We had to use n for something, since we chose not to toss the returned parameter via a _,
					}
				*/
				// fmt.Printf("Why is customMatch returning true? one_field_from_aCard:%s\n", one_field_from_aCard)
				// one_field_from_aCard is nil ??? ^ ^ ^
				// we are only here if customMatch returned true
				return true
			}
		}
	}
	// else
	return false
}

func bool_from_rune(rune_unicode_code_point rune) bool {
	return !unicode.IsLetter(rune_unicode_code_point) // rune_unicode_code_point is any Unicode (sans white space or punctuation)
	// See discussion
}

func customMatch(our_guess, str string) bool {
	// fmt.Println("we are in customMatch")
	// Let's work only with lower-case versions of our data
	ourGuessLower := strings.ToLower(our_guess)
	strLower := strings.ToLower(str)

	// Check for a simple match of one whole within the other
	// This first condition will suffice to catch a single or double numeric digit ourGuessLower when customMatch is called by the first ...
	// ... condition section in check_for_match_in_other_fields
	// if
	if strings.Contains(strLower, ourGuessLower) ||
		strings.Contains(ourGuessLower, strLower) { // i.e. :
		// if strLower contains ourGuessLower, OR ... // Then it is an exact match of our Guess anywhere within the card field
		// if ourGuessLower contains strLower        // Then it is an exact match of the entire card field within our Guess
		// fmt.Printf("this may be why? strLower:%s, ourGuessLower:%s\n", strLower, ourGuessLower)
		// strLower is nil , why??? It was because the last line in the card was ""
		return true
	}

	/*
			// // [2] is an alternate, compact form, of the following single line of code:
				strParts := strings.FieldsFunc(strLower, bool_from_rune)
			// // i.e., sans the stand-alone named func bool_from_rune
		//
			// [2]
			// Split strLower into non-alpha delimited substrings and check if any match ourGuessLower
			strParts := strings.FieldsFunc(strLower, func(r rune) bool {
				return !unicode.IsLetter(r)
			})

	*/

	// // Version which uses a separate named function:
	// Split strLower into non-alpha delimited substrings; then check if any match ourGuessLower
	strParts := strings.FieldsFunc(strLower, bool_from_rune) // only one of two times that this is called
	// strLower is one of the lines from the card. Because this func is called within a range over the fields_from_aCard slice
	// ... we split each line into a sub slice of parts, strings, hence the name strParts. FieldsFunc expects a function as its
	// second argument, one which takes a rune as its parameter, which, in this case, is a rune of a substring of strLower.
	/*
			strings.FieldsFunc expects a function as its second argument, one which takes a rune as its parameter,
			e.g., the bool_from_rune function defined immediately prior to this function.

			When we call strings.FieldsFunc(strLower, bool_from_rune), strings.FieldsFunc internally iterates through the
			characters in the strLower string, and for each character, it converts it to a rune before passing it as an argument
			to the bool_from_rune function.

			So, we don't need to explicitly supply the rune parameter when calling bool_from_rune within strings.FieldsFunc.
			The strings.FieldsFunc function takes care of this conversion for us.

			In summary, strings.FieldsFunc handles the conversion from characters in the input string to rune values and passes
			those rune values to the provided function (bool_from_rune) for processing. This is why we can call bool_from_rune
			without explicitly supplying a rune parameter to it.

		-- For additional foundational explanations of what is going on, please refer to the text which follows this func --
	*/

	for _, part := range strParts { // Read through the slice: strParts to obtain each part
		if len(part) < 3 { // This fixed our issue of "third" matching the "rd" in 3rd
			// fmt.Printf("in customMatch here is a part: %s \n", part)
			// continue looking at parts of strParts, but only compare those that are three or more chars in length
			continue // While this also excludes ALL legitimate two-char parts as potential matches, it should be ok ???
		} else {
			if strings.Contains(ourGuessLower, part) { // If ourGuessLower contains part, exit returning true. This is where "third" is
				// possibly being found within "third" ? yes, it found rd because it was preceded by a 3 which is being used as a delimiter
				// fmt.Printf("\nAfter if strings.Contains : reg customMatch, part is:%s\n", part)
				return true
			}
		}
	}
	return false
}

// -- ADDITIONAL FOUNDATIONAL EXPLANATIONS OF WHAT IS GOING ON (in an earlier section): --
/*
The rune type in Go represents a Unicode code point, which is a numeric value that corresponds to a specific character
in the Unicode standard. In the code you provided, the function bool_from_rune is a custom function that takes a rune as
its argument and returns a boolean value based on a condition.

Here's how it works in the above code:

bool_from_rune is a function that accepts a rune (a Unicode code point) as its parameter.

Inside bool_from_rune, it checks if the given rune (Unicode code point) is not a letter using the unicode.IsLetter function.
The ! operator negates the result, so it returns true if the rune is not a letter and false if it is a letter.

The bool_from_rune function is used as an argument in strings.FieldsFunc

strings.FieldsFunc splits a string into fields based on a provided function, and in this case, it uses the bool_from_rune
function to determine where to split the string.

bool_from_rune checks if a rune is not a letter and is used in the splitting logic to split a string into non-alpha
delimited substrings. This allows us to break the input string into words or substrings based on non-letter characters
(e.g., spaces, punctuation, etc.).

It's a way to customize how strings are split when using strings.FieldsFunc

In the above code, it helps split strLower into non-alpha delimited substrings for further matching.

rune_unicode_code_point is simply a parameter name, and it's used to represent the rune value (Unicode code point) that we pass
to the function. It's a common convention in Go (and in many programming languages) to use descriptive parameter names that
make the code more readable and self-explanatory. In this case, rune_unicode_code_point is used to indicate that the function
operates on a rune value.

The rune parameter represents a single Unicode code point, which can be any character from the Unicode standard.
The name rune_unicode_code_point is just a choice made by the developer, yours truly, who wrote this code; it could have been
named something else. It doesn't have any specific source or significance other than being a descriptive variable name.

When you call the strings.FieldsFunc function with bool_from_rune as its argument, you're not explicitly supplying a
parameter of type rune to it. Instead, the strings.FieldsFunc function itself will handle this.

Here's how it works:

strings.FieldsFunc expects a function that takes a rune as its parameter, e.g., bool_from_rune

When we call strings.FieldsFunc(strLower, bool_from_rune), strings.FieldsFunc internally iterates through the characters
in the strLower string, and for each character, it converts it to a rune before passing it as an argument to the
bool_from_rune function.

So, we don't need to explicitly supply the rune parameter when calling bool_from_rune within strings.FieldsFunc
The strings.FieldsFunc function takes care of this conversion for us.

In summary, strings.FieldsFunc handles the conversion from characters in the input string to rune values and passes
those rune values to the provided function (bool_from_rune) for processing. This is why we can call bool_from_rune
without explicitly supplying a rune parameter.

*/
